# -*- coding: utf-8 -*-
"""game of life.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jgZf0ujfpOu3BiA6_un0zOnvI4lH6K7B
"""

def find_neighbours(arr,i,j):

    if i == 0 or i == len(arr) - 1 or j == 0 or j == len(arr[i]) - 1:
        # corners
        new_neighbors = []

        if j!=0 and i!=0:
            new_neighbors.append(arr[i - 1][j-1])  # top left neighbor

        if i != 0:
            new_neighbors.append(arr[i - 1][j])  # top neighbor

        if i!=0 and j!=len(arr)-1:
            new_neighbors.append(arr[i - 1][j+1])  # top right neighbor

        if j != len(arr[i]) - 1:
            new_neighbors.append(arr[i][j + 1])  # right neighbor
        
        if i != len(arr)-1 and j != len(arr)-1:
            new_neighbors.append(arr[i + 1][j+1])  # bottom right neighbor
            
        if i != len(arr) - 1:
            new_neighbors.append(arr[i + 1][j])  # bottom neighbor

        if j != 0 and i !=len(arr)-1:
            new_neighbors.append(arr[i + 1][j-1])  # bottom left neighbor
            
        if j != 0:
            new_neighbors.append(arr[i][j - 1])  # left neighbor     

    else:
        # add neighbors
        new_neighbors = [
            arr[i - 1][j-1],  # top left neighbor
            arr[i - 1][j],  # top neighbor
            arr[i - 1][j+1],  # top right neighbor
            arr[i][j + 1],  # right neighbor
            arr[i + 1][j+1],  # bottom right neighbor
            arr[i + 1][j],  # bottom neighbor
            arr[i + 1][j-1],  # bottom left neighbor
            arr[i][j - 1]   # left neighbor
        ]


    return new_neighbors

# library for coping list without reference
import copy

# function for generating generation
def game_of_life(gen_1,iteration):
  # plotting first generation
  plt.imshow(gen_1,cmap="Greens")
  plt.show()

  # iterating for a fixed ammount of time
  for it in range(iteration-1):
    # dynamically creating list
    gen_2=[[0]*5 for i in range(5)]
    for i in range(len(gen_1)):
        for j, value in enumerate(gen_1[i]):

          # for dead cell
          if gen_1[i][j]==0:
            neighbours=find_neighbours(gen_1,i,j)
            if neighbours.count(1)<=2 or neighbours.count(1)>3:
              gen_2[i][j]=0
            elif neighbours.count(1)==3:
              gen_2[i][j]=1

          # for live cell
          if gen_1[i][j]==1:
            neighbours=find_neighbours(gen_1,i,j)
            if neighbours.count(1)<2 or neighbours.count(1)>3:
              gen_2[i][j]=0
            elif neighbours.count(1)==2 or neighbours.count(1)==3:
              gen_2[i][j]=1
  # ploting next generations
    plt.imshow(gen_2,cmap="Greens")
    plt.show()
    gen_1 = copy.deepcopy(gen_2)

gen_1=[[0,0,0,0,0],[0,0,1,1,1],[0,1,1,1,0],[0,0,0,0,0],[0,0,0,0,0]]
game_of_life(gen_1,3)